import timeit


def isEven_first(value):
    return value % 2 == 0

"""
В данной реализации, четность определяется по младшему биту двоичного представления числа.
Такая реализация, как показывает тест ниже, работает чуть быстрее,
чем нахождение остатка от деления.
Скорее всего, деление на 2 и остаток от деления на 2 в ассемблере процессора оптимизировано 
именно сдвигами двоичного представления числа и опирается примерно на тот же механизм, который использован
в моей функции, поэтому время работы двух прдложенных реализаций практически не отличается.
"""


def isEven_second(value):
    return bin(value)[-1] == '0'


def main():
    time = 0
    for i in range(1, 1000, 5):
        time += timeit.timeit(lambda: isEven_first(i))
    print(f"first time: {time}")    #53.42949960000001

    time = 0
    for i in range(1, 1000, 5):
        time += timeit.timeit(lambda: isEven_first(i))
    print(f"second time: {time}")   #52.919870300000056


if __name__ == '__main__':
    main()


